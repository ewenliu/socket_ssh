#### 分析

本服务端代码需要在linux上运行。

客户端连接上服务端后，向服务端发送linux命令，服务端能正常接收并且按照linux的终端结果返回给客户端。

难点：粘包问题的解决


#### 服务端逻辑和解决粘包问题思路

服务端逻辑：

1. 与客户端建立连接；
2. 接收客户端发过来的命令，命令一般都比较短（比如ls、ifconig这种），不太会超过默认的1024个字节；
3. 调用subprocess在本地终端执行，获取结果；
4. 将结果返回给客户端。


解决粘包问题简单思路：
1. 考虑到ifconfig等的执行结果长度的不可预测性，极容易产生粘包现象；
2. 服务端分两次发送，先将长度发送给客户端，客户端接收长度后，再将具体数据发送给客户端。

上面这种思路看起来貌似可行，但是长度也是一个不可预测的值，有没有一种更靠的呢？

优化1：
1. 考虑到python有一个struct的模块，它可以将有限长度的数据变成一个长度为4的固定bytes类型数据；
2. 但是还是仍然有长度限制，即使使用 q 格式（对应c语言long long型），也有可能不够用。

优化2：
1. 制作一个header字典，将要传过去的长度存放在字典的键值对中；
2. 使用json打包header；
3. 使用struct打包已经json化的header长度；
4. 客户端先接收json长度，再接收json header；
5. 从header中取到真正的数据长度，开始按照这个长度接收数据。
